#!/bin/bash

# --------------------------------------------------------------------------------
# Consts
# --------------------------------------------------------------------------------

# Cache dir
CACHE_DIR="$HOME/.cache/vifm/preview"
# Path for saving previous dir info
PREV_DIR_FILE="$HOME/.cache/vifm/preview/previous_dir"
# Log file path
LOG_FILE="$HOME/.cache/vifm/preview/log"
# Loggin or not
LOG_ENABLED=0 # 0: No logging | 1: Logging (cause timeloss)

# Images
IMAGE_QUALITY=80
IMAGE_RESIZE="600x600" # the size of vifm window on full screen
# IMAGE_RESIZE="1376x1617" # Measured exact size for me, then remove '--scale-up' option from 'kitten icat'

# Videos
VIDEO_PATTERNS="*.avi *.mp4 *.wmv *.dat *.3gp *.ogv *.mkv *.mpg *.mpeg *.vob fl[icv] *.m2v *.mov *.webm *.ts *.mts *.m4v r[am] *.qt *.divx as[fx]"
VIDEO_FRAME=1000      # frame num for cut, from the movie's start
VIDEO_SCALE="640:360" # width:height
# VIDEO_SCALE="1376:774" # Measured exact size for me, then remove '--scale-up' option from 'kitten icat'

# --------------------------------------------------------------------------------
# Variables
# --------------------------------------------------------------------------------
prev_dir=""
cur_dir=""

# --------------------------------------------------------------------------------
# Functions
# --------------------------------------------------------------------------------

# Loging
function Log() {
   local label="$1"
   local value="$2"
   local length=12
   if [[ $LOG_ENABLED == 1 ]]; then
      printf "%-${length}s: %s\n" "$label" "$value" >>"$LOG_FILE"
   fi
}

# Generate preview & return the hash path
function GeneratePreview() {
   local action=$1
   local file="$2"

   # Get preview filename (hash)
   local hash=$(echo $(realpath "$file") | sha256sum | cut -d' ' -f1) # get hash
   local preview_path="$CACHE_DIR/$hash.jpg"                          # preview path

   # Generate preview
   if [ ! -f "$preview_path" ]; then
      if [[ $action == "image" ]]; then
         magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_RESIZE "$preview_path" &>/dev/null
      elif [[ $action == "video" ]]; then
         ffmpeg -y -i "$1" -vf "select='eq(n,$VIDEO_FRAME)',scale=$VIDEO_SCALE" -frames:v 1 "$preview_path" &>/dev/null
      else
         Log "ERROR" "[action] '$action' not matched."
      fi
   fi
   Log "preview_path" "$action = $preview_path"

   echo $preview_path
}

# Record current directory
function RecordCurDir() {
   echo $cur_dir >"$PREV_DIR_FILE"
}

# Generate previews for all matched files in dir
function GeneratePreviewAll() {
   action=$1
   patterns="$2"

   # List files in the directory and loop through each pattern
   local cnt=0
   for pat in $patterns; do
      Log "pat" "$pat"
      # For each pattern, find matching files
      for file in "$cur_dir"/$pat; do
         # Only proceed if $file is a regular file
         if [[ -f "$file" ]]; then
            Log "file" "$file"
            local preview=$(GeneratePreview $action "$file") # Execute without echo
            ((cnt++))
         fi
      done
   done
   wait
   echo $cnt
}

# Replace % placeholders to variables
function replace_placeholders() {
   local cmd="$1"
   local preview_path="$2"

   # プレースホルダーを実際の変数に置換
   cmd="${cmd//%pw/$pw}"
   cmd="${cmd//%ph/$ph}"
   cmd="${cmd//%px/$px}"
   cmd="${cmd//%py/$py}"
   cmd="${cmd//%tty/$tty}"
   cmd="${cmd//%file/$preview_path}"

   echo "$cmd" # 置換後のコマンドを返す
}

# --------------------------------------------------------------------------------
# Main script
# --------------------------------------------------------------------------------

function main() {
   # # Get directories
   # # Logging
   # if [[ $PROCESS_TYPE == "all" ]]; then
   #    # GeneratePreviewAll()' (in background)
   #    local image_cnt=0
   #    local video_cnt=0
   #    if [[ "$prev_dir" != "$cur_dir" ]]; then # Check if the directory has changed
   #       image_cnt=$(GenerateImagePreviewAll)
   #       Log "function" "GenerateImagePreviewAll() processed: $image_cnt image files"
   #       video_cnt=$(GenerateVideoPreviewAll)
   #       Log "function" "GenerateVideoPreviewAll() processed: $video_cnt video files"
   #    fi
   #    Log "function" "RecordCurDir()"
   #    RecordCurDir "$FILE_PATH"
   # elif [[ $PROCESS_TYPE == "single" ]]; then
   #    # Generate preview for the single file
   #    GeneratePreview "$FILE_PATH" $FT_GROUP sync
   #    # local preview=$(GeneratePreview "$FILE_PATH" $FT_GROUP) # Execute without echo
   #    Log "function" "GeneratePreview() processed: '$FILE_PATH'"
   # else
   #    Log "ERROR" "Invalid process_type '$PROCESS_TYPE'"
   # fi

   local preview_path=$(GeneratePreview $action "$file")
   # cmd="kitten icat --stdin=no --place=${pw}x${ph}@${px}x${py} --scale-up --transfer-mode=file \"$preview_path\" >$tty <$tty"
   # sh -c "$cmd_show"
   local cmd_show=$(replace_placeholders "$cmd_show_template" "$preview_path")
   # echo ${cmd_show_template}
   # echo ${cmd_show}
   sh -c "$cmd_show"
   local processed_cnt=$(GeneratePreviewAll $action "$patterns")
}

# --------------------------------------------------------------------------------
# Main script
# --------------------------------------------------------------------------------

# Get args
action=$1
file=$2
pw=$3
ph=$4
px=$5
py=$6
patterns=$7

# Adjust args
file="${file//\\ / }"       # replate '\ ' to ' '
patterns="${patterns//,/ }" # replace ',' to ' '

# Get env
tty=$VIFM_PREVIEW_TTY
uid=$VIFM_PREVIEW_UID
cmd_show_template=$VIFM_PREVIEW_SHOW
cmd_clear_template=$VIFM_PREVIEW_CLEAR

# Create cache directory
mkdir -p "$CACHE_DIR"

# # Validate
# if [ ! -f "$file" ]; then
#    Log "ERROR" "[filename] '$file' not exists"
#    # exit
# fi

# Get previous/current directories
cur_dir=$(dirname "$(realpath "$file")")
[ ! -f "$PREV_DIR_FILE" ] && prev_dir="" || prev_dir=$(cat "$PREV_DIR_FILE")

# Logging
Log "filename" "$file"
Log "action" "$action"
Log "size" "$pw x $ph"
Log "pos" "$px x $py"
Log "prev_dir" "$prev_dir"
Log "cur_dir" "$cur_dir"

# Clear
if [[ $action == "clear" ]]; then
   kitten icat --clear --silent %N >"$tty" <"$tty" &
   exit
fi

# Execute
main

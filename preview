#!/bin/bash

SCRIPT_NAME='preview.vifm'

# --------------------------------------------------------------------------------
# Functions
# --------------------------------------------------------------------------------

# Loging
Log() {
   local category="$1"
   local label="$2"
   local value="$3"
   local length=20
   if [[ $LOG_ENABLED == true ]]; then
      printf "[ %-${length}s ] %-${length}s: %s\n" "$category" "$label" "$value" >>"$log_file"
   fi
}

GetHash() {
   local path="$1"
   local hash=$(realpath "$path" | sha256sum | cut -d' ' -f1)
   echo "$hash"
}

GetParentDir() {
   local path="$1"
   local parent=$(dirname "$(realpath "$path")")
   echo "$parent"
}

GetStatus() {
   local path="$1"
   local action=$2
   local hash=$(GetHash "$path")

   local hash_filename
   if [[ -d "$path" ]]; then # directory
      hash_filename="$CACHE_DIR/$hash.dir.$action"
   elif [[ -f "$path" ]]; then # file
      hash_filename="$CACHE_DIR/$hash.jpg"
   fi
   if [[ -f "$hash_filename" ]]; then
      echo "done"
   elif [[ -f "$hash_filename.lock" ]]; then
      echo "locked"
   else
      echo "none"
   fi
}

SetStatus() {
   local path="$1"
   local action=$2
   local status=$3
   local hash=$(GetHash "$path")

   if [[ -d "$path" ]]; then # directory
      local hash_filename="$CACHE_DIR/$hash.dir.$action"
      if [[ "$status" == "done" ]]; then
         trash -f "$hash_filename.lock"
         touch "$hash_filename"
      elif [[ "$status" == "locked" ]]; then
         touch "$hash_filename.lock"
      elif [[ "$status" == "none" ]]; then
         trash -f "$hash_filename"
      fi
   elif [[ -f "$path" ]]; then # file
      local hash_filename="$CACHE_DIR/$hash.jpg"
      if [[ "$status" == "done" ]]; then
         trash -f "$hash_filename.lock"
         # touch "$hash_filename" # Do not overwrite the preview file
      elif [[ "$status" == "locked" ]]; then
         touch "$hash_filename.lock"
      elif [[ "$status" == "none" ]]; then
         trash -f "$hash_filename"
      fi
   fi
}

GetEnvironment() {
   local env=""
   [ -n "$NVIM" ] && env="$env nvim"
   [ -n "$TMUX" ] && env="$env tmux"
   [ -z "$TMUX" ] && env="$env terminal"
   echo "${env# }" # (e.g. "nvim tmux")
}

IsContained() {
   local source="$1"
   local target="$2"

   for t in $target; do
      case " $source " in
      *" $t "*) ;;
      *) return 1 ;;
      esac
   done
   return 0
}

# Generate preview & return the hash path
GeneratePreview() {
   local action=$1
   local file="$2"
   # local async="$3"
   Log "preview.start" "$action" "file='$file'"

   # Get preview filename (hash)
   local hash=$(echo $(realpath "$file") | sha256sum | cut -d' ' -f1) # get hash
   local preview_path="$CACHE_DIR/$hash.jpg"                          # preview path

   # Generate preview
   if [ ! -f "$preview_path" ]; then
      if [[ $action == "image" ]]; then
         # magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE $COLOR_SPACE "$preview_path" &>/dev/null # '&' at last works async ?
         local colorspace=$(magick identify -format "%[colorspace]" "$file" 2>/dev/null)

         if [[ $colorspace == "CMYK" && $IMAGE_COLORSPACE_CMYK_TO_SRGB == true ]]; then
            magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE -colorspace sRGB "$preview_path" &>/dev/null
         else
            magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE "$preview_path" &>/dev/null
         fi
      elif [[ $action == "video" ]]; then
         # ffmpeg -y -i "$file" -vf "select='eq(n,$VIDEO_FRAME)',scale=$VIDEO_SIZE" -frames:v 1 "$preview_path" &>/dev/null # '&' at last works async ?
         ffmpegthumbnailer -s $VIDEO_SIZE -q $VIDEO_QUALITY -t $VIDEO_SEEK_TIME -i "$file" -o "$preview_path" &>/dev/null # '&' at last works async ?
      else
         Log "preview.error" "'$action' is not a valid action."
      fi
   fi

   Log "preview.path" "$action" "path='$preview_path'"
   Log "preview.end" "$action" "processed '$file'"
   echo $preview_path
}

# Generate previews for all matched files in dir
GeneratePreviewAll() {
   local action=$1
   local dir="$2"
   local patterns="$3"
   local force="$4"

   local cnt=0

   Log "preview_all.start" "$action" "dir='$dir'"

   local status=$(GetStatus "$dir" "$action")
   if [[ $status == "done" && "$force" != "force" ]]; then
      Log "preview_all.status" "$action" "Skip generating all in '$dir' (already generated)"
      return 1
   elif [[ $status == "locked" ]]; then
      Log "preview_all.status" "$action" "Skip generating all in '$dir' (generating now)"
      return 1
   fi

   SetStatus "$dir" "$action" "locked"

   # List files in the directory and loop through each pattern
   IFS=',' read -r -a pat_array <<<"$patterns"
   local jobs=()
   for pat in "${pat_array[@]}"; do
      Log "preview_all.pattern" "$action" "pat='$pat'"
      # For each pattern, find matching files
      for file in "$dir"/$pat; do
         # Only proceed if $file is a regular file
         if [[ -f "$file" ]]; then
            Log "preview_all.file" "$action" "file='$file'"
            # local preview_path=$(GeneratePreview $action "$file" &)
            GeneratePreview $action "$file" &
            # jobs+=($!) # TODO: REMOVE
            ((cnt++))
         fi
      done
   done

   # wait "${jobs[@]}" # ERROR: "PID * is not a valid child process" # TODO: REMOVE
   wait

   SetStatus "$dir" "$action" "done"
   Log "preview_all.end" "$action" "processed $cnt files in '$dir'"
}

# Replace % placeholders to actual values
GetCmd() {
   local cmd="$1"
   local preview_path="$2"
   Log "get_cmd.start" "" ""
   Log "get_cmd.template" "" "cmd='$1'"
   Log "get_cmd.path" "" "preview_path='$preview_path'"

   # Replace
   cmd="${cmd//%pw/$pw}"
   cmd="${cmd//%ph/$ph}"
   cmd="${cmd//%px/$px}"
   cmd="${cmd//%py/$py}"
   cmd="${cmd//%tty/$VIFM_PREVIEW_TTY}"
   if [[ $preview_path != '' ]]; then
      cmd="${cmd//%file/$preview_path}"
   fi

   Log "get_cmd.cmd" "" "$cmd"
   echo "$cmd"
}

# Clear
Clear() {
   Log "clear.start" "" ""
   local cmd_clear=$(GetCmd "$CLEAR_CMD_TEMPLATE" "")
   sh -c "$cmd_clear"
   Log "clear.end" "" ""
}

# Show preview
Show() {
   local preview_path="$1"
   Log "show.start" "" ""
   # Adjust x,y on nvim
   if [[ $nvim ]]; then
      px=$((px + VIFM_PREVIEW_WIN_X + VIFM_PREVIEW_WIN_BORDER_WIDTH))
      py=$((py + VIFM_PREVIEW_WIN_Y + VIFM_PREVIEW_WIN_BORDER_WIDTH))
   fi
   local cmd_show=$(GetCmd "$SHOW_CMD_TEMPLATE" "$preview_path")
   sh -c "$cmd_show"
   Log "show.end" "" "$preview_path"
}

# --------------------------------------------------------------------------------
# Main script
# --------------------------------------------------------------------------------
Main() {
   # Logging
   Log "" "" ""
   Log "main.start" "$subcmd" "----------------------------------------------------------"
   Log "ctx" "subcmd" "$subcmd"
   Log "ctx" "path" "$path"
   Log "ctx" "size" "$pw x $ph"
   Log "ctx" "pos" "$px x $py"
   Log "ctx" "cur_dir" "$cur_dir"
   Log "ctx" "cmd_show_template" "$SHOW_CMD_TEMPLATE"
   Log "ctx" "cmd_clear_template" "$CLEAR_CMD_TEMPLATE"

   # Create cache directory
   mkdir -p "$CACHE_DIR"

   # Execute actions
   if [[ $subcmd == "clear" ]]; then
      # clear
      Clear
   elif [[ $subcmd == "image" ]]; then
      # Generate preview files for all images in parent dir in background
      GeneratePreviewAll $subcmd "$parent" $IMAGE_PATTERNS >/dev/null 2>&1 &
      # Preview a image
      local preview_path=$(GeneratePreview $subcmd "$path" $IMAGE_PATTERNS)
      Show "$preview_path"
   elif [[ $subcmd == "video" ]]; then
      # Generate preview files for all videos in parent dir in background
      GeneratePreviewAll $subcmd "$parent" $VIDEO_PATTERNS >/dev/null 2>&1 &
      # Preview a video
      local preview_path=$(GeneratePreview $subcmd "$path" $VIDEO_PATTERNS)
      Show "$preview_path"
   fi
}

# --------------------------------------------------------------------------------
# Source config
# --------------------------------------------------------------------------------
config="$VIFM/scripts/$SCRIPT_NAME/config"
if [ -f "$config" ]; then
   source "$config"
elif [ -f "$config.default" ]; then
   source "$config.default"
else
   echo "[ERROR]: 'config' or 'config.default' not exists."
   exit
fi

# --------------------------------------------------------------------------------
# Global variables
# --------------------------------------------------------------------------------

# Get args
subcmd=$1
path=$2
pw=$3
ph=$4
px=$5
py=$6

# Adjust args
path="${path//\\ / }" # replate '\ ' to ' '

# Path for log
log_file="$CACHE_DIR/log"

# Previous/current directories
parent=$(GetParentDir "$path")

# Environment (e.g. "nvim tmux" | "nvim" | "terminal" )
env=$(GetEnvironment)

# On nvim or not
nvim=$(IsContained "$env" "nvim")

# Execute Main()
Main

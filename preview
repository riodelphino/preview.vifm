#!/bin/bash

SCRIPT_NAME='preview.vifm'

# --------------------------------------------------------------------------------
# Functions
# --------------------------------------------------------------------------------

# Loging
function Log() {
   local category="$1"
   local label="$2"
   local value="$3"
   local length=20
   if [[ $LOG_ENABLED == true ]]; then
      printf "[ %-${length}s ] %-${length}s: %s\n" "$category" "$label" "$value" >>"$log_file"
   fi
}

function LockFileName() {
   local target=$1
   local action=$2
   local path=$3
   local lock_file_name
   if [[ $target == "directory" ]]; then
      local dir=$path
      lock_file_name="$dir/.preview-vifm.$action.lock"
   elif [[ $target == "file" ]]; then
      local dir=$(dirname "$path")
      local base=$(basename "$path")
      lock_file_name="$dir/.${base}.lock"
   fi
   echo "$lock_file_name"
   Log "lock" "$action" "lock_file_name='$lock_file_name'"
}

Lock() {
   local lock_file_name=$1
   touch "$lock_file_name"
}

Unlock() {
   local lock_file_name=$1
   rm "$lock_file_name"
}

function IsLocked() {
   local lock_file_name=$1
   [[ -f "$lock_file_name" ]]
}

# get environment as array
# like ['nvim', 'tmux'] or ['nvim', 'terminal'] or ['terminal'] or ['tmux']
GetEnvironment() {
   local env_array=()
   if [ -n "$NVIM" ]; then
      env_array+=("nvim")
   fi
   if [ -n "$TMUX" ]; then
      env_array+=("tmux")
   else
      env_array+=("terminal")
   fi
   echo "${env_array[@]}"
}

function IsArrayContained() {
   source=$1
   search=$2

   found_all=true

   for t in "${search[@]}"; do
      if ! echo "${source[@]}" | grep -qw "$t"; then
         found_all=false
         break
      fi
   done
   echo found_all
}

# Generate preview & return the hash path
function GeneratePreview() {
   local action=$1
   local file="$2"
   # local async="$3"
   Log "preview.start" "$action" "file='$file'"

   # Get preview filename (hash)
   local hash=$(echo $(realpath "$file") | sha256sum | cut -d' ' -f1) # get hash
   local preview_path="$CACHE_DIR/$hash.jpg"                          # preview path

   # Generate preview
   if [ ! -f "$preview_path" ]; then
      if [[ $action == "image" ]]; then
         # magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE $COLOR_SPACE "$preview_path" &>/dev/null # '&' at last works async ?
         local colorspace=$(magick identify -format "%[colorspace]" "$file" 2>/dev/null)

         if [[ $colorspace == "CMYK" && $IMAGE_COLORSPACE_CMYK_TO_SRGB == true ]]; then
            magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE -colorspace sRGB "$preview_path" &>/dev/null
         else
            magick "$file" -quality $IMAGE_QUALITY -resize $IMAGE_SIZE "$preview_path" &>/dev/null
         fi
      elif [[ $action == "video" ]]; then
         # ffmpeg -y -i "$file" -vf "select='eq(n,$VIDEO_FRAME)',scale=$VIDEO_SIZE" -frames:v 1 "$preview_path" &>/dev/null # '&' at last works async ?
         ffmpegthumbnailer -s $VIDEO_SIZE -q $VIDEO_QUALITY -t $VIDEO_SEEK_TIME -i "$file" -o "$preview_path" &>/dev/null # '&' at last works async ?
      else
         Log "preview.error" "'$action' is not a valid action."
      fi
   fi

   Log "preview.path" "$action" "path='$preview_path'"
   Log "preview.end" "$action" "processed '$file'"
   echo $preview_path
}

# Generate previews for all matched files in dir
function GeneratePreviewAll() {
   local action=$1
   local dir="$2"
   local patterns="$3"

   local cnt=0

   Log "preview_all.start" "$action" "dir='$dir'"

   local lock_file_name=$(LockFileName "directory" $action "$dir")
   if IsLocked "$lock_file_name"; then
      Log "preview_all.locked" "$action" "Skip generating all in '$dir'"
      return 1
   fi

   Lock $lock_file_name

   # List files in the directory and loop through each pattern
   IFS=',' read -r -a pat_array <<<"$patterns"
   local jobs=()
   for pat in "${pat_array[@]}"; do
      Log "preview_all.pattern" "$action" "pat='$pat'"
      # For each pattern, find matching files
      for file in "$dir"/$pat; do
         # Only proceed if $file is a regular file
         if [[ -f "$file" ]]; then
            Log "preview_all.file" "$action" "file='$file'"
            local preview_path=$(GeneratePreview $action "$file" &)
            jobs+=($!)
            ((cnt++))
         fi
      done
   done

   # wait "${jobs[@]}" # ERROR: "PID * is not a valid child process"
   wait
   Unlock $lock_file_name
   Log "preview_all.end" "$action" "processed $cnt files in '$dir'"
}

# Replace % placeholders to actual values
function GetCmd() {
   local cmd="$1"
   local preview_path="$2"
   Log "get_cmd.start" "" ""
   Log "get_cmd.template" "" "cmd='$1'"
   Log "get_cmd.path" "" "preview_path='$preview_path'"

   # Replace
   cmd="${cmd//%pw/$pw}"
   cmd="${cmd//%ph/$ph}"
   cmd="${cmd//%px/$px}"
   cmd="${cmd//%py/$py}"
   cmd="${cmd//%tty/$VIFM_PREVIEW_TTY}"
   if [[ $preview_path != '' ]]; then
      cmd="${cmd//%file/$preview_path}"
   fi

   Log "get_cmd.cmd" "" "$cmd"
   echo "$cmd"
}

# Clear
function Clear() {
   Log "clear.start" "" ""
   local cmd_clear=$(GetCmd "$CLEAR_CMD_TEMPLATE" "")
   sh -c "$cmd_clear"
   Log "clear.end" "" ""
}

# Show preview
function Show() {
   local preview_path="$1"
   Log "show.start" "" ""
   # Adjust x,y on nvim
   if [[ $nvim ]]; then
      px=$((px + VIFM_PREVIEW_WIN_X + VIFM_PREVIEW_WIN_BORDER_WIDTH))
      py=$((py + VIFM_PREVIEW_WIN_Y + VIFM_PREVIEW_WIN_BORDER_WIDTH))
   fi
   local cmd_show=$(GetCmd "$SHOW_CMD_TEMPLATE" "$preview_path")
   sh -c "$cmd_show"
   Log "show.end" "" "$preview_path"
}

# --------------------------------------------------------------------------------
# Main script
# --------------------------------------------------------------------------------
function Main() {
   # Logging
   Log "" "" ""
   Log "main.start" "$subcmd" "----------------------------------------------------------"
   Log "ctx" "subcmd" "$subcmd"
   Log "ctx" "path" "$path"
   Log "ctx" "size" "$pw x $ph"
   Log "ctx" "pos" "$px x $py"
   Log "ctx" "cur_dir" "$cur_dir"
   Log "ctx" "cmd_show_template" "$SHOW_CMD_TEMPLATE"
   Log "ctx" "cmd_clear_template" "$CLEAR_CMD_TEMPLATE"

   # Create cache directory
   mkdir -p "$CACHE_DIR"

   # Execute actions
   if [[ $subcmd == "clear" ]]; then # clear
      Clear
   elif [[ $subcmd == "dir" ]]; then # generate for current dir
      GeneratePreviewAll image "$path" $IMAGE_PATTERNS &
      GeneratePreviewAll video "$path" $VIDEO_PATTERNS &
   elif [[ $subcmd == "image" ]]; then # generate & show preview for a image
      local preview_path=$(GeneratePreview $subcmd "$path" $IMAGE_PATTERNS &)
      Show "$preview_path"
   elif [[ $subcmd == "video" ]]; then # generate & show preview for a video
      local preview_path=$(GeneratePreview $subcmd "$path" $VIDEO_PATTERNS &)
      Show "$preview_path"
   fi
}

# --------------------------------------------------------------------------------
# Source config
# --------------------------------------------------------------------------------
config="$VIFM/scripts/$SCRIPT_NAME/config"
if [ -f "$config" ]; then
   source "$config"
elif [ -f "$config.default" ]; then
   source "$config.default"
else
   echo "[ERROR]: 'config' or 'config.default' not exists."
   exit
fi

# --------------------------------------------------------------------------------
# Global variables
# --------------------------------------------------------------------------------

# Get args
subcmd=$1
path=$2
pw=$3
ph=$4
px=$5
py=$6

# Adjust args
path="${path//\\ / }" # replate '\ ' to ' '

# Omit for action:clear to cause error
# # Validate
# if [ ! -f "$file" ]; then
#    Log "ERROR" "[filename] '$file' not exists"
#    # exit
# fi

# Path for log
log_file="$CACHE_DIR/log"

# Previous/current directories
cur_dir=$(dirname "$(realpath "$path")")

# Environment, like nvim, tmux, terminal
envrionment=$(GetEnvironment)

# On nvim or not
nvim=$(IsArrayContained environment {"nvim"})

# Execute Main()
Main
